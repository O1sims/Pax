import osimport requestsfrom copy import deepcopyfrom analytics.UnitAnalysis import get_unit_datafrom analytics.Geolocation import calculate_actor_to_asset_time, get_asset_actor_distancefrom analytics.ActionAnalysis import action_force, get_action_time, get_inherent_probability_of_successfrom analytics.HostileResponses import HostileResponses, get_counter_actionsfrom analytics.Criticality import calculate_asset_criticality, calculate_asset_impactfrom analytics.SystemAnalysis import number_of_vulnerabilities, asset_from_id, remove_asset_by_id, get_asset_threatsfrom analytics.Config import action_time_map, threat_label_level_map, risk_label_from_score, \    criticality_label_from_score, probability_label_from_scoredef task_likelihood_from_risk_data(risk_data, task):    asset_risk = risk_data[task['objective']]    for i in range(len(asset_risk['actions'])):        if asset_risk['actions'][i].keys()[0] == task['effect']:            return asset_risk['risks'][i]['likelihoodScore']def get_task_dependency_success(action, action_data):    """    Calculates the probability of the dependent tasks failing.    Returns a value between 0 (all dependencies will be successful) and 100 (all dependencies will be unsuccessful)    """    if 'dependencies' in action.keys() and action['dependencies']:        dependent_probabilities = []        for dependent_action_id in action['dependencies']:            for a in action_data:                if a['taskId'] == dependent_action_id:                    dependent_probabilities.append(                        (100 - float(a['probabilityOfFailure'])) / 100                    )        dependent_success = reduce(lambda x, y: x * y, dependent_probabilities)    else:        dependent_success = 1    return dependent_success * 100def get_unit_success(actor_id):    """    Calculates the probability of the unit failing.    Returns a value between 0 (the unit will be successful) and 100 (the unit will be unsuccessful)    """    unit_data = get_unit_data(        unit_id=actor_id    )    return 16.66 * unit_data['effectsCapability']def get_inherent_success(effect, asset_id, assets):    objective_type = asset_from_id(        asset_id=asset_id,        assets=assets,        asset_type=True    )    inherent_success = get_inherent_probability_of_success(        effect=effect,        type=objective_type    )    return inherent_successdef get_time_success(effect, asset_id, time_frame, assets):    objective_type = asset_from_id(        asset_id=asset_id,        assets=assets,        asset_type=True    )    action_time = get_action_time(        effect=effect,        type=objective_type    )    if action_time > time_frame:        return 0    else:        return 100 - int(100 * float(action_time)/time_frame)def unit_on_time(system_id, asset_id, actor_id, time_frame):    distance = get_asset_actor_distance(        system_id=system_id,        asset_id=asset_id,        actor_id=actor_id    )    distance_time = calculate_actor_to_asset_time(        distance=distance    )    probability_on_time = 10    if time_frame < distance_time:        probability_on_time = int((float(time_frame) / float(distance_time) * 100)**(1-(time_frame/10)))    return probability_on_timedef get_task_success(inherent_success, dependency_success, unit_success, time_success, weights):    fail = inherent_success * dependency_success * unit_success * time_success    if fail == 0:        return 0    w_i = weights[0] * inherent_success    w_d = weights[1] * dependency_success    w_u = weights[2] * unit_success    w_t = weights[3] * time_success    task_success = int(w_i + w_d + w_u + w_t)    return task_successdef get_likelihood_of_failure(system_id, system_data, action_data, action):    """    Calculates the probability that a certain task will fail.    If a task has a 'MOVE' effect, then the probability of failure will depend on whether the actor can make it    to the objective on time.    If a task is more complex, then the probability of failure will depend on whether it's dependencies likelihood of    failure    Returns an integer between 0 (successful) and 1 (impossible)    """    if action['effect'].upper() == 'MOVE':        return unit_on_time(            system_id=system_id,            asset_id=action['objective'],            actor_id=action['actor'],            time_frame=action['timeFrame']        )    likelihood_of_dependency_success = get_task_dependency_success(        action=action,        action_data=action_data    )    likelihood_of_unit_success = get_unit_success(        actor_id=action['actor']    )    likelihood_of_time_success = get_time_success(        effect=action['effect'],        asset_id=action['objective'],        time_frame=action['timeFrame'],        assets=system_data['assets']    )    likelihood_of_inherent_success = get_inherent_success(        effect=action['effect'],        asset_id=action['objective'],        assets=system_data['assets']    )    likelihood_of_task_success = get_task_success(        inherent_success=likelihood_of_inherent_success,        dependency_success=likelihood_of_dependency_success,        unit_success=likelihood_of_unit_success,        time_success=likelihood_of_time_success,        weights=[0.25, 0.25, 0.25, 0.25]    )    likelihood_of_task_failure = 100 - likelihood_of_task_success    return likelihood_of_task_failuredef get_risk_score(threat_alpha, vulnerability_score):    if vulnerability_score == 0 and threat_alpha == 0:        return 12    elif vulnerability_score > 0 and threat_alpha == 0:        return 30 + (3 * vulnerability_score)    elif vulnerability_score == 0 and threat_alpha > 0:        return 20 + (3 * threat_alpha)    elif vulnerability_score > 0 and threat_alpha == 1:        return 45    elif vulnerability_score > 0 and threat_alpha == 2:        return 55    elif vulnerability_score > 0 and threat_alpha == 3:        return 65    elif vulnerability_score > 0 and threat_alpha >= 4:        return 85    else:        return 50def generate_risk_summary(asset, action, vuln_no, likelihood_score):    likelihood = probability_label_from_score(probability=likelihood_score)    if action['effect'].upper() == 'MOVE':        risk_summary = "There is a " + likelihood.lower() + " risk of moving the " + \                       get_unit_data(unit_id=action['actor'])['name'] + " to the " + asset['name'] + "."        if likelihood_score > 99:            risk_summary = risk_summary + " This is because the " + get_unit_data(unit_id=action['actor'])['name'] + \                           " will not make it to the asset in time."        if likelihood_score > 80:            risk_summary = risk_summary + " This is because the " + get_unit_data(unit_id=action['actor'])['name'] + \                           " may not make it to the asset in time."        return risk_summary    else:        risk_summary = "There is a " + likelihood.lower() + " risk associated with assigning the " + action[            'effect'].lower() + " effect taken by " + get_unit_data(unit_id=action['actor'])['name'] + " against " + \                       asset['name'] + "."    action_time = action_time_map()    if action_time[action['effect']] > action['timeFrame']:        risk_summary = risk_summary + " This is because it will take too long to complete this task."    if vuln_no == 0 and action['effect'] != 'DESTROY':        risk_summary = risk_summary + " Note that this asset has no known vulnerabilities to exploit."    return risk_summarydef default_risk_evaluation(asset_id, risk_score, risk_label, criticality, criticality_label, impact, impact_label):    risk_summary = "Not dealing with this asset leads to a " + criticality_label.lower() + " risk of mission failure."    risk_evaluation = {        asset_id: {            'risks': [                {                    'riskScore': risk_score,                    'riskLabel': risk_label,                    'criticalityScore': criticality,                    'criticalityLabel': criticality_label,                    'impactScore': impact,                    'impactLabel': impact_label,                    'likelihoodLabel': 'Low',                    'likelihoodScore': 1,                    'riskSummary': risk_summary                }            ],            'hostileResponses': None,            'actions': None        }    }    return risk_evaluationdef arrange_assets_for_dependencies(action_data, assets):    """    This function arranges the asset list such that assets with actions without dependencies are listed first,    then assets with dependencies, etc.    """    sorted_assets = []    tasks_finished = []    if action_data is None \            or len(action_data) == 0 \            or 'dependencies' not in action_data[0].keys():        return assets    else:        while len(action_data) > 0:            for action in action_data:                if set(action['dependencies']).issubset(set(tasks_finished)):                    asset_to_sort = asset_from_id(                        asset_id=action['objective'],                        assets=assets                    )                    if asset_to_sort is not None:                        sorted_assets.append(asset_to_sort)                    tasks_finished.append(action['taskId'])                    assets = remove_asset_by_id(                        asset_id=action['objective'],                        assets=assets                    )                    action_data.remove(action)        returned_assets = sorted_assets + assets    return returned_assetsdef arrange_actions_for_dependencies(action_data):    """    This function arranges the action list such that actions without dependencies are listed first, then assets with    those dependencies, and so on.    """    prioritised_action_ids = []    prioritised_action_data = []    if action_data is None or len(action_data) == 0:        return None    else:        if 'dependencies' in action_data[0].keys():            blank_dependencies = True            for action in action_data:                if len(action['dependencies']) > 0:                    blank_dependencies = False            if blank_dependencies:                return action_data            for action in action_data:                if not action['dependencies']:                    prioritised_action_data.append(action)                    prioritised_action_ids.append(action['taskId'])                    action_data.remove(action)            while len(action_data) > 0:                for action in action_data:                    if action['dependencies'][0] in prioritised_action_ids:                        prioritised_action_data.append(action)                        prioritised_action_ids.append(action['taskId'])                        action_data.remove(action)        else:            return action_data    return prioritised_action_datadef calculate_asset_risk_scores(system_id, system_data, action_data, vulnerability_scores, threat_alphas):    asset_risk_scores = {}    assets = arrange_assets_for_dependencies(        action_data=deepcopy(action_data),        assets=deepcopy(system_data['assets'])    )    action_data = arrange_actions_for_dependencies(        action_data=deepcopy(action_data)    )    for i in range(len(assets)):        asset = assets[i]        criticality_score = calculate_asset_criticality(            asset=asset        )        criticality_label = criticality_label_from_score(            criticality_score=criticality_score        )        risk_score = get_risk_score(            vulnerability_score=vulnerability_scores[asset['id']],            threat_alpha=threat_alphas[asset['id']]        )        risk_label = risk_label_from_score(            risk_score=risk_score        )        vuln_no = number_of_vulnerabilities(            asset_id=asset['id'],            vulnerabilities=system_data['vulnerabilities']        )        impact_score = calculate_asset_impact(            asset=asset        )        impact_label = risk_label_from_score(            risk_score=impact_score        )        if action_data is None:            asset_risk_scores.update(default_risk_evaluation(                asset_id=asset['id'],                risk_score=risk_score,                risk_label=risk_label,                criticality=criticality_score,                criticality_label=criticality_label,                impact=impact_score,                impact_label=impact_label            ))        else:            actions_to_asset = []            asset_action_risk = []            actions = []            most_dangerous = []            most_likely = []            for action in action_data:                if action['objective'] == assets[i]['id']:                    actions_to_asset.append(action)            if len(actions_to_asset) > 0:                for action in actions_to_asset:                    action['probabilityOfFailure'] = get_likelihood_of_failure(                        system_id=system_id,                        system_data=system_data,                        action_data=action_data,                        action=action                    )                    likelihood_label = probability_label_from_score(                        probability=action['probabilityOfFailure']                    )                    risk_summary = generate_risk_summary(                        asset=assets[i],                        action=action,                        vuln_no=vuln_no,                        likelihood_score=action['probabilityOfFailure']                    )                    unit_affiliation = get_unit_data(action['actor'])['affiliation']                    if unit_affiliation == 'FRIENDLY':                        most_likely_response = HostileResponses(                            system_data=system_data                        ).get_response(                            action=action,                            risk_score=risk_score,                            asset_id=assets[i]['id'],                            most_likely=True                        )                        most_dangerous_response = HostileResponses(                            system_data=system_data                        ).get_response(                            action=action,                            risk_score=risk_score,                            asset_id=assets[i]['id'],                            most_dangerous=True,                            most_likely_asset=most_likely_response['objective']                        )                        if most_likely_response not in most_likely:                            most_likely.append(most_likely_response)                        if most_dangerous_response not in most_dangerous:                            most_dangerous.append(most_dangerous_response)                        hostile_responses = {                            'mostDangerous': most_dangerous,                            'mostLikely': most_likely                        }                    else:                        hostile_responses = None                    action_to_take = get_counter_actions(                        assets=system_data['assets'],                        objective=action['objective'],                        effect=action['effect'])                    actions.append({                        action['effect']: action_to_take                    })                    asset_action_risk.append({                        'riskScore': risk_score,                        'riskLabel': risk_label,                        'criticalityScore': criticality_score,                        'criticalityLabel': criticality_label,                        'impactScore': impact_score,                        'impactLabel': impact_label,                        'likelihoodLabel': likelihood_label,                        'likelihoodScore': action['probabilityOfFailure'],                        'riskSummary': risk_summary,                    })                asset_risk_scores.update({                    assets[i]['id']: {                        'risks': asset_action_risk,                        'hostileResponses': hostile_responses,                        'actions': actions                    }                })            else:                likelihood_label = 'Low'                likelihood_score = 1                risk_summary = "Not dealing with this asset leads to a " + criticality_label.lower() + " risk of mission failure."                asset_action_risk.append({                    'riskScore': risk_score,                    'riskLabel': risk_label,                    'criticalityScore': criticality_score,                    'criticalityLabel': criticality_label,                    'impactScore': impact_score,                    'impactLabel': impact_label,                    'likelihoodScore': likelihood_score,                    'likelihoodLabel': likelihood_label,                    'riskSummary': risk_summary                })                asset_risk_scores.update({                    assets[i]['id']: {                        'risks': asset_action_risk,                        'hostileResponses': None                    }                })    return asset_risk_scoresdef calculate_threat_alpha(asset, threats):    max_threat_level = 0    asset_threats = get_asset_threats(        asset_id=asset['id'],        threats=threats    )    for threat in asset_threats:        threat_level = threat_label_level_map(            threat_label=threat['threatLevel']        )        if threat_level > max_threat_level:            max_threat_level = threat_level    return max_threat_leveldef evaluate_system_risk(system_id, system_data, action_data=None):    threat_alphas = {}    vulnerability_nos = {}    for asset in system_data['assets']:        vulnerability_nos[asset['id']] = number_of_vulnerabilities(            asset_id=asset['id'],            vulnerabilities=system_data['vulnerabilities']        )        threat_alphas[asset['id']] = calculate_threat_alpha(            asset=asset,            threats=system_data['threats']        )    asset_risk_scores = calculate_asset_risk_scores(        system_id=system_id,        system_data=system_data,        action_data=action_data,        vulnerability_scores=vulnerability_nos,        threat_alphas=threat_alphas    )    return asset_risk_scoresclass SystemRisk:    def __init__(self, system_id=None, system_data=None, action_data=None):        self.action_data = action_data        self.force = action_force(action_list=action_data)        if system_data is None:            self.system_id = system_id            r = requests.get('http://' + os.environ.get('C2_REST') + 'system/' + self.system_id)            self.data = r.json()        else:            self.system_id = system_data['id']            self.data = system_data    def if_asset_is_treated(self, asset):        self.data['vulnerabilities'] = list(            filter(lambda d: asset['id'] not in d['assets'], self.data['vulnerabilities']))        new_system_risk = evaluate_system_risk()        return new_system_risk[asset['id']]['riskLabel']